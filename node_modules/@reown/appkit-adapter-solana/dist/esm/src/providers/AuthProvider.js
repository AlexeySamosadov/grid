import { isVersionedTransaction } from '@solana/wallet-adapter-base';
import { PublicKey, Transaction, VersionedTransaction } from '@solana/web3.js';
import base58 from 'bs58';
import { ConstantsUtil } from '@reown/appkit-common';
import { ChainController, SIWXUtil, getPreferredAccountType } from '@reown/appkit-controllers';
import { W3mFrameProvider } from '@reown/appkit-wallet';
import { withSolanaNamespace } from '../utils/withSolanaNamespace.js';
import { ProviderEventEmitter } from './shared/ProviderEventEmitter.js';
export class AuthProvider extends ProviderEventEmitter {
    constructor(params) {
        super();
        this.id = ConstantsUtil.CONNECTOR_ID.AUTH;
        this.name = ConstantsUtil.CONNECTOR_NAMES.AUTH;
        this.type = 'AUTH';
        this.chain = ConstantsUtil.CHAIN.SOLANA;
        this.provider = params.w3mFrameProvider;
        this.requestedChains = params.chains;
        this.getActiveChain = params.getActiveChain;
    }
    get publicKey() {
        const address = ChainController.state.chains.get(ConstantsUtil.CHAIN.SOLANA)?.accountState
            ?.address;
        return address ? new PublicKey(address) : undefined;
    }
    get chains() {
        const availableChainIds = this.provider.getAvailableChainIds();
        return this.requestedChains.filter(requestedChain => availableChainIds.includes(requestedChain.caipNetworkId));
    }
    async connect(params = {}) {
        const chainId = params.chainId || this.getActiveChain()?.id;
        const preferredAccountType = getPreferredAccountType('solana');
        await SIWXUtil.authConnectorAuthenticate({
            authConnector: this.provider,
            chainId: withSolanaNamespace(chainId),
            socialUri: params.socialUri,
            preferredAccountType,
            chainNamespace: ConstantsUtil.CHAIN.SOLANA
        });
        if (!this.publicKey) {
            throw new Error('Failed to connect to the wallet');
        }
        this.emit('connect', this.publicKey);
        return this.publicKey.toBase58();
    }
    async disconnect() {
        await this.provider.disconnect();
        this.emit('disconnect', undefined);
    }
    async signMessage(message) {
        if (!this.publicKey) {
            throw new Error('Wallet not connected');
        }
        const result = await this.provider.request({
            method: 'solana_signMessage',
            params: { message: base58.encode(message), pubkey: this.publicKey.toBase58() },
            chainNamespace: this.chain
        });
        return base58.decode(result.signature);
    }
    async signTransaction(transaction) {
        const result = await this.provider.request({
            method: 'solana_signTransaction',
            params: { transaction: this.serializeTransaction(transaction) },
            chainNamespace: this.chain
        });
        const decodedTransaction = base58.decode(result.transaction);
        if (isVersionedTransaction(transaction)) {
            return VersionedTransaction.deserialize(decodedTransaction);
        }
        return Transaction.from(decodedTransaction);
    }
    async signAndSendTransaction(transaction, options) {
        const serializedTransaction = this.serializeTransaction(transaction);
        const result = await this.provider.request({
            method: 'solana_signAndSendTransaction',
            params: {
                transaction: serializedTransaction,
                options
            },
            chainNamespace: this.chain
        });
        return result.signature;
    }
    async sendTransaction(transaction, connection, options) {
        const signedTransaction = await this.signTransaction(transaction);
        const signature = await connection.sendRawTransaction(signedTransaction.serialize(), options);
        return signature;
    }
    async signAllTransactions(transactions) {
        const result = await this.provider.request({
            method: 'solana_signAllTransactions',
            params: {
                transactions: transactions.map(transaction => this.serializeTransaction(transaction))
            },
            chainNamespace: this.chain
        });
        return result.transactions.map((encodedTransaction, index) => {
            const transaction = transactions[index];
            if (!transaction) {
                throw new Error('Invalid solana_signAllTransactions response');
            }
            const decodedTransaction = base58.decode(encodedTransaction);
            if (isVersionedTransaction(transaction)) {
                return VersionedTransaction.deserialize(decodedTransaction);
            }
            return Transaction.from(decodedTransaction);
        });
    }
    async request(args) {
        return this.provider.request({
            method: args.method,
            params: args.params,
            chainNamespace: this.chain
        });
    }
    async getAccounts() {
        if (!this.publicKey) {
            return Promise.resolve([]);
        }
        return Promise.resolve([
            {
                namespace: this.chain,
                address: this.publicKey.toBase58(),
                type: 'eoa'
            }
        ]);
    }
    serializeTransaction(transaction) {
        return base58.encode(new Uint8Array(transaction.serialize({ verifySignatures: false })));
    }
}
//# sourceMappingURL=AuthProvider.js.map